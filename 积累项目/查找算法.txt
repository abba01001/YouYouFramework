1. 线性查找（Linear Search）:简单粗暴，直接遍历整个数组
适用条件：
数组未排序或部分有序。
数据量较小。
不要求高效率，只需简单实现。

时间复杂度： O(n)（最坏情况下，需要遍历整个数组）
空间复杂度： O(1)（仅需常数级的额外空间）

2. 二分查找（Binary Search）:比较目标元素和数组中间元素的大小关系，将查找范围缩小一半，直到找到目标元素或查找范围为空。
适用条件：
数组必须是有序的。
数据量较大。
要求高效率，希望在较短时间内找到目标元素。

时间复杂度： O(log n)（每一步将查找范围缩小一半）
空间复杂度： O(1)（仅需常数级的额外空间）


3. 哈希查找（Hash Search）:通过哈希函数将键映射到数组的特定位置，然后在该位置进行查找。它需要一个合适的哈希函数来确保元素分布均匀。
适用条件：
需要快速的插入和查找操作。
数据量较大。
可以通过哈希函数将元素映射到哈希表的不同位置。

平均时间复杂度： O(1)（在理想情况下，哈希查找是常数时间的）
最坏时间复杂度： O(n)（在发生冲突且解决冲突的代价很高时）
空间复杂度： O(n)（取决于哈希表的大小，通常是线性的）

（哈希函数是一种将“键”转换为“索引”的逻辑规则，它的设计好坏对哈希表的性能影响巨大。优良的哈希函数能够最大程度的减少哈希冲突）
哈希函数一般都是取余操作。

哈希冲突：两个或更多不同的键通过哈希函数映射到相同的哈希值或索引位置的情况。
在哈希表中，每个键都应该有唯一的哈希值对应的索引位置，但由于哈希函数的有限输出范围，不同的键可能会产生相同的哈希值，导致冲突

哈希冲突的处理
(1)链地址法（Separate Chaining）
。在每个哈希表的位置上，维护一个链表（或其他数据结构，如红黑树），将所有映射到相同位置的键值对存储在链表中。
当发生冲突时，新的键值对可以被添加到链表的末尾。

(2)开放地址法（Open Addressing）： 
在发生冲突时，通过一定的规则（例如线性探测、二次探测等）在哈希表中寻找下一个可用的位置。
这种方法避免了使用额外的数据结构，但需要谨慎选择探测规则，以防止聚集（clustering）现象，即键在哈希表中分布不均匀。

4.斐波那契查找:
斐波那契查找和二分查找相似。都是用于有序数组的查找算法
都采用了分治的思想，将查找范围逐步缩小.
时间复杂度都是O(log n)

5.二叉树查找:（适合  1、有序数据 2、频繁的查找操作）
特点：左子树的所有节点的值都小于根节点的值，而右子树的所有节点的值都大于根节点的值
先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围
前序查找：
中序查找：
后序查找：

6.平衡二叉树：为了解决二叉树可能不平衡的问题，是一种特殊的二叉搜索树，它保持了树的平衡性，确保左右子树的高度差不超过一个常数。
常见的平衡二叉树包括 AVL树(自平衡二叉搜索树) 和红黑树。

AVL树：
对于每个节点，左子树和右子树的高度差不超过1。
对于每个节点，左子树和右子树都是 AVL 树。
通过在插入和删除操作中进行旋转操作，AVL 树能够自动维持平衡
这确保了 AVL 树的高度保持在对数级别，使得查找、插入和删除等操作的时间复杂度都在O(log n)。

红黑树：
根节点是黑色    叶节点是不存储数据的黑色空节点（此处可以忽略不显示这个节点）
任何相邻的两个节点不能同时为红色
任意节点到其可到达的叶节点包含相同数量的黑色节点

AVL树（查找效率<log n,每次插入删除都要做复杂的调整） VS 红黑树(适合频繁插入删除，但查找效率比AVL低)

概念：B树（B+  B-）   2-3树   2-3-4树    红黑树