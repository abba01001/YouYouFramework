使用递归写一个n的阶乘。
int RecursiveMultiply(int n)
{
    if (n == 1)
    {
        return 1;
    }
    else if (n < 1)
    {
        return 0;
    }
    else
    {
        return n * RecursiveMultiply(n - 1);
    }
}

反射的定义：可以在运行的时候用字符串的方式去动态创建类或者调用类

反射是一个什么样的机制，缺点是什么？
反射是一种在运行时检查、获取和操作程序结构的机制
性能开销（毕竟是运行时进行查找和检查）。安全性（可以直接访问私有属性和方法）。

il2cpp是什么？mono呢？ 编码技术。

il2cpp的流程  c#编译为中间语言（IL Intermediate Language），中间语言转换为C++，C++再编译为机器码

mono的流程  c#编译为中间语言（IL Intermediate Language，Mono 运行时（虚拟机）解释执行
在运行时，Mono 运行时环境会解释和执行这些 IL 代码。它提供了一个虚拟机（类似于 Java 虚拟机），负责将 IL 代码翻译成特定平台上的本地机器码。

总体来说，Mono 使用了即时编译（Just-In-Time Compilation，JIT）的方式，即在程序运行时将 IL 代码编译成本地机器码。这使得 C# 代码能够在不同平台上运行，而不需要预先为每个平台生成特定的本地机器码。
与之相反，IL2CPP 采用的是一种静态的编译方式，将 C# 代码在构建时直接编译为 C++ 代码，然后再编译成本地机器码。这种方式带来了一些性能上的优势，同时也增加了构建时间和二进制文件的大小。

使用IL2CPP的优势包括：
性能提升： 由于C++代码更接近底层，通常可以提供更好的性能。
跨平台支持： 生成的C++代码可以在多个平台上运行，而不需要重新编译。
代码保护： C++代码难以逆向工程，因此使用IL2CPP可以提高代码的安全性。
IL2CPP主要用于Unity项目的发布版本，而在编辑器中运行时通常使用Mono运行时


写过shader吗？顶点着色器与片元着色器都是干嘛的？
顶点着色器主要是将顶点从模型空间转换到裁剪空间里，然后进行一些计算啥的
片段着色器就是计算每个像素最终形成的颜色

lua中如何模拟一个继承？介绍__index和__newindex方法？

在 Lua 中，我们可以使用元表（metatable）来模拟继承。
元表中的 __index 元方法用于处理表中不存在的键的查找操作，而 __newindex 元方法则用于处理表中不存在的键的赋值操作

lua的垃圾回收是怎么样实现的?
垃圾回收是 Lua 用于管理内存的一种机制，通过自动检测和释放不再使用的内存，确保程序运行过程中不会出现内存泄漏的问题。
在 Lua 中，垃圾回收主要依赖于两种技术：引用计数和标记-清除。

lua的弱表是什么？介绍它的作用?
在 Lua 中，弱表是一种特殊的表，它使用弱引用来管理键和值。
弱引用意味着如果某个对象只在弱表中存在引用，而在其他地方没有强引用，那么这个对象可能会被垃圾回收机制自动移除，从而避免内存泄漏。
弱表主要用于灵活地管理对象的生命周期，特别是在对象被用作表的键或值时。

怎么优化ab包的加载，让他在内存和性能上取得一个比较好的表现

优化AssetBundle（AB）包的加载可以提高游戏的内存效率和性能。以下是一些建议：
合理使用AssetBundle： 确保正确划分和使用AssetBundle，避免将所有资源都打包到一个大的AB中。将相关资源打包在一起，以便按需加载，减少不必要的资源加载。
精细划分AB包： 将场景中常用的资源和不常用的资源分别打包，以减小加载时的数据量。这可以提高加载速度，同时减小内存开销。
异步加载： 使用异步加载方式加载AB包，以充分利用多线程，提高整体性能。Unity提供了AssetBundle.LoadAssetAsync等异步加载方法。
缓存机制： 实现合理的缓存机制，避免重复加载相同的AB包。可以使用对象池技术，对已加载的资源进行缓存，以便后续重复使用。
内存管理： 确保在使用完资源后及时释放，避免内存泄漏。Unity的AssetBundle.Unload方法可以用于卸载AB包。
压缩和分包： 使用合适的压缩算法对AB包进行压缩，以减小网络传输和磁盘存储开销。对于大型游戏，可以考虑使用分包策略，根据场景需求动态加载。
热更新策略： 对于需要热更新的游戏，设计良好的热更新策略可以在不重新发布应用的情况下更新资源。这可以通过服务器端下发差异包，或者使用资源版本管理机制实现。
优化资源： 在制作阶段优化资源，包括纹理压缩、模型优化等，以减小AB包的体积和加载时间。
使用StreamingAssets： 对于较大的资源，可以考虑将其放置在StreamingAssets目录下，通过UnityWebRequest等方式实现异步加载，以提高性能。
性能分析工具： 使用Unity的性能分析工具，如Profiler，进行AB包加载性能分析。这可以帮助你识别潜在的性能瓶颈并进行优化。

优化资源： 在制作阶段优化资源，包括纹理压缩、模型优化、动画片段优化等，以减小AB包的体积和加载时间。

如何做条件移除一个数组中符合条件的元素？
        List<int> numbersList = new List<int>{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        // 移除数组中符合条件的元素（偶数）
        numbersList.RemoveAll((num) => {
            return num % 2 == 0;
        });
        Debug.Log("Filtered List: " + string.Join(", ", numbersList));

了解过哈希表吗？介绍它的实现原理，如果哈希碰撞了怎么办？都有什么哈希碰撞算法？
哈希表是由数组、哈希函数和碰撞解决方法三部分组成的数据结构。
碰撞解决方法:链地址法和开放寻址法。

protobuf是什么?protobuf的实现原理是什么？
protobuf就是一种二进制序列化格式的数据结构

做过什么编辑器工具？

ipairs和pairs的区别。
ipairs 只能遍历数组部分，而且遍历是按照整数键从小到大（从1开始）的顺序进行的。
pairs 可以遍历表中所有的键值对，不仅仅限于整数键。遍历的顺序没有特定规定。

lua的表底层是一个数组和一个哈希表组成
ipairs 只能顺序遍历数组部分，是因为它基于数组的顺序索引。
ipairs 是通过逐一递增的整数索引来遍历 Lua 表中的元素的。这意味着它依赖于表的数组部分，而数组的特性是有序的且索引是连续的整数。

lua和c#的交互
（重点就是虚拟机）

游戏引擎通常会提供优化工具和技术，如批处理（Batching）、GPU Instancing、静态和动态批处理等，来减少 Draw Call 的数量，从而提高游戏的性能。
减少 Draw Call 的优化是常见的图形性能优化手段之一。



在 C# 中，数据类型可以分为两大类：值类型（Value Types）和引用类型（Reference Types）。这两者在内存中的存储方式有所不同。
值类型（Value Types）：
基本数据类型：
bool
byte, sbyte
short, ushort
int, uint
long, ulong
float, double, decimal
char
其他值类型：
结构体（Structs）
枚举（Enums）


引用类型（Reference Types）：
类（Class）
接口（Interface）
委托（Delegate）
数组（Array）
字符串（String）
动态对象（dynamic）
存储位置：
值类型： 存储在栈上，除非它们是嵌套在引用类型中。
引用类型： 存储在堆上，变量本身存储在栈上，它包含一个引用指向堆上的实际对象。

拆箱过程的堆栈操作是怎么做的？为什么要避免装箱拆箱？装箱拆箱主要性能消耗在哪个？

避免装箱拆箱的原因：

性能开销：
装箱和拆箱都涉及额外的内存分配和复制操作，导致性能开销。
拆箱时可能发生类型检查和转换，进一步增加开销。

内存开销：
装箱会在堆上创建对象，增加了内存开销。
拆箱时可能需要复制数据，增加了额外的内存开销。

jpg和png的格式有什么区别？他们在显存上有没有差别？
jpg有损压缩.png无损压缩。
显存上的主要差异不在于图像格式，而在于图像的分辨率、色彩深度以及是否使用了透明度等因素。
由于 JPEG 是有损压缩，可能导致一些细节的损失，但在显存中存储的是解压缩后的位图数据。

介绍一下红点系统？

如何显示3d模型到UI界面
用RawImage，创建RenderTexture

ui的释放时机？？？？


C#接口与抽象类的相似点是什么？区别呢？

接口（Interface）： 接口定义了一种契约，规定了类应该具有的方法、属性或事件。类通过实现接口来保证其具有指定的行为。
接口强调了"是什么"而不是"如何"。通过实现接口，一个类表明它具备某种能力或特定的行为。

抽象类（Abstract Class）： 抽象类可以包含抽象方法和具体方法。
它提供了一些通用的实现，但其中可能包含一些未实现的抽象方法，需要派生类提供具体实现。
抽象类强调了一种基类和派生类之间的关系，允许提供通用实现并要求派生类扩展或实现特定的行为。

在使用接口和抽象类时，程序员可以定义一组规范，确保类遵循这些规范。
这有助于提高代码的可维护性、可扩展性和可读性，同时也促使代码的组织和设计更加清晰。

C# 中的接口（interface）和抽象类（abstract class）有一些相似点，这些相似点包括：

抽象性： 接口和抽象类都是抽象的，不能被直接实例化，需要被继承或者实现。
约束行为： 接口和抽象类都可以用于约束子类或实现类的行为，要求其提供特定的方法或属性。
多态性： 通过接口和抽象类可以实现多态性，即使用基类类型的引用来引用子类的对象。
提供共享的契约： 两者都可以用于定义一组规范，确保类遵循这些规范，从而提高代码的可维护性和可读性。
不能被实例化： 接口和抽象类都不能被直接实例化，只能被继承或实现。
允许声明抽象成员： 两者都可以包含抽象成员，即没有实现的方法，需要在派生类中提供具体实现。
虽然接口和抽象类有这些相似点，但也有一些关键的区别，例如接口不能包含字段，而抽象类可以包含字段；
一个类可以实现多个接口，但只能继承一个抽象类等。这些区别决定了它们在不同的场景和设计目标下的使用。

多态：
通常通过方法重写（override）和虚方法（virtual）来实现

结构体（struct）和类（class）
区别：

值类型 vs 引用类型：
结构体： 结构体是值类型，它在栈上分配内存，变量直接包含其实际数据。
类： 类是引用类型，它在堆上分配内存，变量存储的是对象的引用。

继承：
结构体： 结构体不支持继承。不能从结构体派生新的类型。
类： 类支持继承。一个类可以从另一个类派生出新的类型。

默认构造函数：
结构体： 如果没有定义任何构造函数，编译器会生成默认的无参数构造函数。
类： 如果没有定义任何构造函数，编译器也会生成默认的无参数构造函数。

拷贝行为：
结构体： 结构体在赋值和传递时会被拷贝，每个实例都是独立的。
类： 类在赋值和传递时是通过引用进行的，不会发生拷贝。

堆和栈分配：
结构体： 结构体通常在栈上分配内存，但在某些情况下，如果它是类的成员，也可能在堆上。
类： 类的实例通常在堆上分配内存。

内存分配区域：
结构体： 结构体的实例通常分配在调用它们的方法的栈上。如果结构体是类的成员，它可能会存储在类的实例的内存中。
类： 类的实例通常分配在堆上，通过引用访问。类的成员变量可以包含其他引用类型的实例，它们的数据可能存储在堆上。

在使用结构体和类时，需要根据具体情况选择合适的类型。
一般来说，结构体适用于较小的、简单的数据结构，而类适用于需要引用语义、继承和较复杂的对象。

静态类：静态类的成员在整个应用程序域内是共享的，因此任何地方都可以调用静态类的方法和访问静态成员。
静态方法：（不管类是不是静态类还是正常的类），不用实例化类就能调这个静态方法

in ref out的区别？
用于传递参数的关键字。
ref传参前参数要有初始值。可以改变参数值
out传参前不用初始化参数。方法内部必须给参数赋值，可以改变参数值
in只读。不能改变参数值

c#中，委托是个什么样的概念？
委托就相当于一个容器，可以把所有的方法丢进去，一起执行。可以动态的去添加/移除方法
委托的缺点？耦合度强

观察者模式？
观察者模式是一种行为设计模式，用于定义一种一对多的依赖关系，
使得当一个对象的状态发生改变时，所有依赖于它的对象都能够得到通知并自动更新。观察者模式又被称为发布-订阅模式。

多播委托和观察者模式都可以用于实现一对多的通知机制，但它们的机制和使用场景略有不同。
多播委托更适合简单的事件处理，而观察者模式更适合在对象之间建立松散的耦合关系。

c#当中的协程是什么？与平时上写的代码有什么流程上的区别？
协程（Coroutine）是一种特殊的方法，可以通过 yield 关键字来实现异步的执行流程。
协程允许你暂停方法的执行，并在稍后的时间点恢复执行。
这种机制使得在单个方法中可以执行长时间运行的任务，而不会阻塞整个程序

lua遍历一个table有哪几种方式？iparis和paris区别是什么？
ipairs pairs next for

lua如何实现面向对象编程？
 Lua并没有严格的类和对象的概念，而是通过元表和表来模拟面向对象编程的一些特性

lua当中的闭包是一个什么样的概念？
就是一个方法里面可以访问这个方法外面定义的局部变量

lua当中的弱表是什么？怎么样开启？
__mode赋值

描述一下lua的垃圾回收？
下是Lua垃圾回收的一般过程：

标记阶段（Mark）：

1从全局变量和局部变量的根开始，通过引用关系遍历所有的可达对象，将这些对象标记为活动对象。
标记过程中，会识别出哪些对象是可以访问的，而哪些对象是可以被回收的。
清除阶段（Sweep）：

2垃圾回收器遍历整个堆，清理那些未被标记的对象，即被认为是垃圾的对象。
清理后，内存空间会被重新整理，为将来的对象分配提供更多的连续空间。
回收阶段（Collect）：

3在清除阶段后，垃圾回收器可能会执行一些附加的收尾工作，例如处理弱表、调整内存分配策略等。

垃圾回收是在Lua的虚拟机运行时进行的，通常是通过在合适的时机自动触发的。
垃圾回收过程是透明的，对于Lua程序员来说，不需要手动管理内存。

Lua还允许通过手动调用 collectgarbage 函数来显式触发垃圾回收。

怎么优化ab包的加载，让它在内存和性能上取得一个比较好的表现？
（重点）

内存中的资源是一个怎么样的保存策略？
（重点）

项目中lua包的分包策略。

如何判断一个资源是否需要更新？

假如玩家错过了几个版本，该如何更新到最新的版本？

怎么实现断点续传功能？

了解过什么寻路算法？介绍一下a星算法和势能寻路，它俩区别是什么？

前端如何实时展示一个特别大的排行榜？后端该怎么实现这个排行榜的快速排行？
分页加载：将排行榜分成多个页面，每次只加载当前页面的数据，随着用户滚动或翻页，动态加载更多数据。这可以减轻前端渲染的压力。
虚拟滚动：使用虚拟滚动技术，只渲染用户可见的部分，而不是整个排行榜。这可以减少DOM元素数量，提高性能。

项目用到了ecs吗？它对性能有多少提升？为什么ecs会对性能带来提升？
Entity-Component-System (ECS) 是一种架构模式，它与传统的基于继承的对象模型不同
而是将对象分解为实体（Entity）、组件（Component）和系统（System）

ECS提升性能的关键在于优化数据布局、支持并行处理、提供高度可组合性
从而更有效地利用硬件资源，减少系统之间的耦合，实现轻量级实体管理。

介绍一下gpu skin和gpu instance。
GPU Skinning（图形处理单元蒙皮）	GPU Instancing（图形处理单元实例化）

什么情况下使用状态机，什么时候使用行为树

状态机的一个潜在问题是状态之间可能存在高度耦合。
状态之间的耦合性指的是一个状态的修改可能需要影响到其他多个状态，这可能导致代码难以维护、理解和扩展。

有限状态机则是舍掉了每个状态的优先级，而这样换来的则是高拓展性，每新增状态时只要加转换条件就行了。另外每个状态都分开也增加了可维护性。
但是因为舍掉优先级把任何两个状态的转换都用条件判断来实现这样的不便之处是每个状态都要为它可以转换到的状态写转换条件.
这样无疑增加了工作量。可以参考unity的动画状态机当状态太多的时候。

行为树则更像是我们平时写脚本
既保留了每个状态的优先级关系，省略了状态机因舍弃状态优先级而增加的状态转换条件，又可以模块化出各个状态，实现高拓展性和高维护性