使用递归写一个n的阶乘。
int RecursiveMultiply(int n)
{
    if (n == 1)
    {
        return 1;
    }
    else if (n < 1)
    {
        return 0;
    }
    else
    {
        return n * RecursiveMultiply(n - 1);
    }
}

反射的定义：可以在运行的时候用字符串的方式去动态创建类或者调用类

反射是一个什么样的机制，缺点是什么？
反射是一种在运行时检查、获取和操作程序结构的机制
性能开销（毕竟是运行时进行查找和检查）。安全性（可以直接访问私有属性和方法）。

il2cpp是什么？mono呢？ 编码技术。

il2cpp的流程  c#编译为中间语言（IL Intermediate Language），中间语言转换为C++，C++再编译为机器码

mono的流程  c#编译为中间语言（IL Intermediate Language，Mono 运行时（虚拟机）解释执行
在运行时，Mono 运行时环境会解释和执行这些 IL 代码。它提供了一个虚拟机（类似于 Java 虚拟机），负责将 IL 代码翻译成特定平台上的本地机器码。

总体来说，Mono 使用了即时编译（Just-In-Time Compilation，JIT）的方式，即在程序运行时将 IL 代码编译成本地机器码。这使得 C# 代码能够在不同平台上运行，而不需要预先为每个平台生成特定的本地机器码。
与之相反，IL2CPP 采用的是一种静态的编译方式，将 C# 代码在构建时直接编译为 C++ 代码，然后再编译成本地机器码。这种方式带来了一些性能上的优势，同时也增加了构建时间和二进制文件的大小。

使用IL2CPP的优势包括：
性能提升： 由于C++代码更接近底层，通常可以提供更好的性能。
跨平台支持： 生成的C++代码可以在多个平台上运行，而不需要重新编译。
代码保护： C++代码难以逆向工程，因此使用IL2CPP可以提高代码的安全性。
IL2CPP主要用于Unity项目的发布版本，而在编辑器中运行时通常使用Mono运行时


写过shader吗？顶点着色器与片元着色器都是干嘛的？
顶点着色器主要是将顶点从模型空间转换到裁剪空间里，然后进行一些计算啥的
片段着色器就是计算每个像素最终形成的颜色

lua中如何模拟一个继承？介绍__index和__newindex方法？

在 Lua 中，我们可以使用元表（metatable）来模拟继承。
元表中的 __index 元方法用于处理表中不存在的键的查找操作，而 __newindex 元方法则用于处理表中不存在的键的赋值操作

lua的垃圾回收是怎么样实现的?
垃圾回收是 Lua 用于管理内存的一种机制，通过自动检测和释放不再使用的内存，确保程序运行过程中不会出现内存泄漏的问题。
在 Lua 中，垃圾回收主要依赖于两种技术：引用计数和标记-清除。

lua的弱表是什么？介绍它的作用?
在 Lua 中，弱表是一种特殊的表，它使用弱引用来管理键和值。
弱引用意味着如果某个对象只在弱表中存在引用，而在其他地方没有强引用，那么这个对象可能会被垃圾回收机制自动移除，从而避免内存泄漏。
弱表主要用于灵活地管理对象的生命周期，特别是在对象被用作表的键或值时。

怎么优化ab包的加载，让他在内存和性能上取得一个比较好的表现

优化AssetBundle（AB）包的加载可以提高游戏的内存效率和性能。以下是一些建议：
合理使用AssetBundle： 确保正确划分和使用AssetBundle，避免将所有资源都打包到一个大的AB中。将相关资源打包在一起，以便按需加载，减少不必要的资源加载。
精细划分AB包： 将场景中常用的资源和不常用的资源分别打包，以减小加载时的数据量。这可以提高加载速度，同时减小内存开销。
异步加载： 使用异步加载方式加载AB包，以充分利用多线程，提高整体性能。Unity提供了AssetBundle.LoadAssetAsync等异步加载方法。
缓存机制： 实现合理的缓存机制，避免重复加载相同的AB包。可以使用对象池技术，对已加载的资源进行缓存，以便后续重复使用。
内存管理： 确保在使用完资源后及时释放，避免内存泄漏。Unity的AssetBundle.Unload方法可以用于卸载AB包。
压缩和分包： 使用合适的压缩算法对AB包进行压缩，以减小网络传输和磁盘存储开销。对于大型游戏，可以考虑使用分包策略，根据场景需求动态加载。
热更新策略： 对于需要热更新的游戏，设计良好的热更新策略可以在不重新发布应用的情况下更新资源。这可以通过服务器端下发差异包，或者使用资源版本管理机制实现。
优化资源： 在制作阶段优化资源，包括纹理压缩、模型优化等，以减小AB包的体积和加载时间。
使用StreamingAssets： 对于较大的资源，可以考虑将其放置在StreamingAssets目录下，通过UnityWebRequest等方式实现异步加载，以提高性能。
性能分析工具： 使用Unity的性能分析工具，如Profiler，进行AB包加载性能分析。这可以帮助你识别潜在的性能瓶颈并进行优化。

优化资源： 在制作阶段优化资源，包括纹理压缩、模型优化、动画片段优化等，以减小AB包的体积和加载时间。

如何做条件移除一个数组中符合条件的元素？
        List<int> numbersList = new List<int>{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        // 移除数组中符合条件的元素（偶数）
        numbersList.RemoveAll((num) => {
            return num % 2 == 0;
        });
        Debug.Log("Filtered List: " + string.Join(", ", numbersList));

了解过哈希表吗？介绍它的实现原理，如果哈希碰撞了怎么办？都有什么哈希碰撞算法？
哈希表是由数组、哈希函数和碰撞解决方法三部分组成的数据结构。
碰撞解决方法:链地址法和开放寻址法。

protobuf是什么?protobuf的实现原理是什么？
protobuf就是一种二进制序列化格式的数据结构

做过什么编辑器工具？

ipairs和pairs的区别。
ipairs 只能遍历数组部分，而且遍历是按照整数键从小到大（从1开始）的顺序进行的。
pairs 可以遍历表中所有的键值对，不仅仅限于整数键。遍历的顺序没有特定规定。

lua的表底层是一个数组和一个哈希表组成
ipairs 只能顺序遍历数组部分，是因为它基于数组的顺序索引。
ipairs 是通过逐一递增的整数索引来遍历 Lua 表中的元素的。这意味着它依赖于表的数组部分，而数组的特性是有序的且索引是连续的整数。

lua和c#的交互
（重点就是虚拟机）

游戏引擎通常会提供优化工具和技术，如批处理（Batching）、GPU Instancing、静态和动态批处理等，来减少 Draw Call 的数量，从而提高游戏的性能。
减少 Draw Call 的优化是常见的图形性能优化手段之一。



在 C# 中，数据类型可以分为两大类：值类型（Value Types）和引用类型（Reference Types）。这两者在内存中的存储方式有所不同。
值类型（Value Types）：
基本数据类型：
bool
byte, sbyte
short, ushort
int, uint
long, ulong
float, double, decimal
char
其他值类型：
结构体（Structs）
枚举（Enums）


引用类型（Reference Types）：
类（Class）
接口（Interface）
委托（Delegate）
数组（Array）
字符串（String）
动态对象（dynamic）
存储位置：
值类型： 存储在栈上，除非它们是嵌套在引用类型中。
引用类型： 存储在堆上，变量本身存储在栈上，它包含一个引用指向堆上的实际对象。

拆箱过程的堆栈操作是怎么做的？为什么要避免装箱拆箱？装箱拆箱主要性能消耗在哪个？

避免装箱拆箱的原因：

性能开销：
装箱和拆箱都涉及额外的内存分配和复制操作，导致性能开销。
拆箱时可能发生类型检查和转换，进一步增加开销。

内存开销：
装箱会在堆上创建对象，增加了内存开销。
拆箱时可能需要复制数据，增加了额外的内存开销。

jpg和png的格式有什么区别？他们在显存上有没有差别？
jpg有损压缩.png无损压缩。
显存上的主要差异不在于图像格式，而在于图像的分辨率、色彩深度以及是否使用了透明度等因素。
由于 JPEG 是有损压缩，可能导致一些细节的损失，但在显存中存储的是解压缩后的位图数据。

介绍一下红点系统？

如何显示3d模型到UI界面
用RawImage，创建RenderTexture

ui的释放时机？？？？


C#接口与抽象类的相似点是什么？区别呢？

接口（Interface）： 接口定义了一种契约，规定了类应该具有的方法、属性或事件。类通过实现接口来保证其具有指定的行为。
接口强调了"是什么"而不是"如何"。通过实现接口，一个类表明它具备某种能力或特定的行为。

抽象类（Abstract Class）： 抽象类可以包含抽象方法和具体方法。
它提供了一些通用的实现，但其中可能包含一些未实现的抽象方法，需要派生类提供具体实现。
抽象类强调了一种基类和派生类之间的关系，允许提供通用实现并要求派生类扩展或实现特定的行为。

在使用接口和抽象类时，程序员可以定义一组规范，确保类遵循这些规范。
这有助于提高代码的可维护性、可扩展性和可读性，同时也促使代码的组织和设计更加清晰。

C# 中的接口（interface）和抽象类（abstract class）有一些相似点，这些相似点包括：

抽象性： 接口和抽象类都是抽象的，不能被直接实例化，需要被继承或者实现。
约束行为： 接口和抽象类都可以用于约束子类或实现类的行为，要求其提供特定的方法或属性。
多态性： 通过接口和抽象类可以实现多态性，即使用基类类型的引用来引用子类的对象。
提供共享的契约： 两者都可以用于定义一组规范，确保类遵循这些规范，从而提高代码的可维护性和可读性。
不能被实例化： 接口和抽象类都不能被直接实例化，只能被继承或实现。
允许声明抽象成员： 两者都可以包含抽象成员，即没有实现的方法，需要在派生类中提供具体实现。
虽然接口和抽象类有这些相似点，但也有一些关键的区别，例如接口不能包含字段，而抽象类可以包含字段；
一个类可以实现多个接口，但只能继承一个抽象类等。这些区别决定了它们在不同的场景和设计目标下的使用。

多态：
通常通过方法重写（override）和虚方法（virtual）来实现

结构体（struct）和类（class）
区别：

值类型 vs 引用类型：
结构体： 结构体是值类型，它在栈上分配内存，变量直接包含其实际数据。
类： 类是引用类型，它在堆上分配内存，变量存储的是对象的引用。

继承：
结构体： 结构体不支持继承。不能从结构体派生新的类型。
类： 类支持继承。一个类可以从另一个类派生出新的类型。

默认构造函数：
结构体： 如果没有定义任何构造函数，编译器会生成默认的无参数构造函数。
类： 如果没有定义任何构造函数，编译器也会生成默认的无参数构造函数。

拷贝行为：
结构体： 结构体在赋值和传递时会被拷贝，每个实例都是独立的。
类： 类在赋值和传递时是通过引用进行的，不会发生拷贝。

堆和栈分配：
结构体： 结构体通常在栈上分配内存，但在某些情况下，如果它是类的成员，也可能在堆上。
类： 类的实例通常在堆上分配内存。

内存分配区域：
结构体： 结构体的实例通常分配在调用它们的方法的栈上。如果结构体是类的成员，它可能会存储在类的实例的内存中。
类： 类的实例通常分配在堆上，通过引用访问。类的成员变量可以包含其他引用类型的实例，它们的数据可能存储在堆上。

在使用结构体和类时，需要根据具体情况选择合适的类型。
一般来说，结构体适用于较小的、简单的数据结构，而类适用于需要引用语义、继承和较复杂的对象。

静态类：静态类的成员在整个应用程序域内是共享的，因此任何地方都可以调用静态类的方法和访问静态成员。
静态方法：（不管类是不是静态类还是正常的类），不用实例化类就能调这个静态方法

in ref out的区别？
用于传递参数的关键字。
ref传参前参数要有初始值。可以改变参数值
out传参前不用初始化参数。方法内部必须给参数赋值，可以改变参数值
in只读。不能改变参数值

c#中，委托是个什么样的概念？
委托就相当于一个容器，可以把所有的方法丢进去，一起执行。可以动态的去添加/移除方法
委托的缺点？耦合度强

观察者模式？
观察者模式是一种行为设计模式，用于定义一种一对多的依赖关系，
使得当一个对象的状态发生改变时，所有依赖于它的对象都能够得到通知并自动更新。观察者模式又被称为发布-订阅模式。

多播委托和观察者模式都可以用于实现一对多的通知机制，但它们的机制和使用场景略有不同。
多播委托更适合简单的事件处理，而观察者模式更适合在对象之间建立松散的耦合关系。

c#当中的协程是什么？与平时上写的代码有什么流程上的区别？
协程（Coroutine）是一种特殊的方法，可以通过 yield 关键字来实现异步的执行流程。
协程允许你暂停方法的执行，并在稍后的时间点恢复执行。
这种机制使得在单个方法中可以执行长时间运行的任务，而不会阻塞整个程序

lua遍历一个table有哪几种方式？iparis和paris区别是什么？
ipairs pairs next for

lua如何实现面向对象编程？
 Lua并没有严格的类和对象的概念，而是通过元表和表来模拟面向对象编程的一些特性

lua当中的闭包是一个什么样的概念？
就是一个方法里面可以访问这个方法外面定义的局部变量

lua当中的弱表是什么？怎么样开启？
__mode赋值

描述一下lua的垃圾回收？
下是Lua垃圾回收的一般过程：

标记阶段（Mark）：

1从全局变量和局部变量的根开始，通过引用关系遍历所有的可达对象，将这些对象标记为活动对象。
标记过程中，会识别出哪些对象是可以访问的，而哪些对象是可以被回收的。
清除阶段（Sweep）：

2垃圾回收器遍历整个堆，清理那些未被标记的对象，即被认为是垃圾的对象。
清理后，内存空间会被重新整理，为将来的对象分配提供更多的连续空间。
回收阶段（Collect）：

3在清除阶段后，垃圾回收器可能会执行一些附加的收尾工作，例如处理弱表、调整内存分配策略等。

垃圾回收是在Lua的虚拟机运行时进行的，通常是通过在合适的时机自动触发的。
垃圾回收过程是透明的，对于Lua程序员来说，不需要手动管理内存。

Lua还允许通过手动调用 collectgarbage 函数来显式触发垃圾回收。

怎么优化ab包的加载，让它在内存和性能上取得一个比较好的表现？
（重点）

内存中的资源是一个怎么样的保存策略？
（重点）

项目中lua包的分包策略。

如何判断一个资源是否需要更新？

假如玩家错过了几个版本，该如何更新到最新的版本？

怎么实现断点续传功能？

了解过什么寻路算法？介绍一下a星算法和势能寻路，它俩区别是什么？

前端如何实时展示一个特别大的排行榜？后端该怎么实现这个排行榜的快速排行？
分页加载：将排行榜分成多个页面，每次只加载当前页面的数据，随着用户滚动或翻页，动态加载更多数据。这可以减轻前端渲染的压力。
虚拟滚动：使用虚拟滚动技术，只渲染用户可见的部分，而不是整个排行榜。这可以减少DOM元素数量，提高性能。

项目用到了ecs吗？它对性能有多少提升？为什么ecs会对性能带来提升？
Entity-Component-System (ECS) 是一种架构模式，它与传统的基于继承的对象模型不同
而是将对象分解为实体（Entity）、组件（Component）和系统（System）

ECS提升性能的关键在于优化数据布局、支持并行处理、提供高度可组合性
从而更有效地利用硬件资源，减少系统之间的耦合，实现轻量级实体管理。

介绍一下gpu skin和gpu instance。
GPU Skinning（图形处理单元蒙皮）	GPU Instancing（图形处理单元实例化）

什么情况下使用状态机，什么时候使用行为树

状态机的一个潜在问题是状态之间可能存在高度耦合。
状态之间的耦合性指的是一个状态的修改可能需要影响到其他多个状态，这可能导致代码难以维护、理解和扩展。

有限状态机则是舍掉了每个状态的优先级，而这样换来的则是高拓展性，每新增状态时只要加转换条件就行了。另外每个状态都分开也增加了可维护性。
但是因为舍掉优先级把任何两个状态的转换都用条件判断来实现这样的不便之处是每个状态都要为它可以转换到的状态写转换条件.
这样无疑增加了工作量。可以参考unity的动画状态机当状态太多的时候。

行为树则更像是我们平时写脚本
既保留了每个状态的优先级关系，省略了状态机因舍弃状态优先级而增加的状态转换条件，又可以模块化出各个状态，实现高拓展性和高维护性

fsm在AI状态少的时候好用，一旦行为多起来要加很多过渡条件。行为树要好用点

如果AI逻辑不是很复杂，那么就没有必要用行为树，用行为树反而会有点难。

行为树的要点：根节点(Root)，叶子节点(Leaf)
组合节点
(
Sequence：序列节点。所有子节点成功返回成功，否则返回失败（&&/AND）
Selector：选择节点。有一个子节点返回成功则返回成功，所有子节点失败则返回失败（||/OR）
Parallel：并行节点。执行所有子节点，当有N个（count>N>0）子节点返回成功则返回成功，所有子节点返回失败则返回失败
还有很多以此为基础的变种节点，例如ReverseSequence，RandomSequence，ReverseSelector，RandomSelector等等
）
修饰节点(Decorator)自定义子节点的行为。例如Invert节点，反转其子节点返回的状态信息；Repeat节点，按照给定次数重复执行子节点；
TimeOut节点，规定子节点的执行时间，超过某个阈值不论子节点状态如何直接返回失败。修饰节点有且只有一个子节点。
节点有三种基本状态，Success(成功)、Failure(失败)、Running(运行中)

行为树的每个节点之间都还是孤立的，就比如如果一个节点的运行要根据上一个节点计算的值来执行的话，我们就没有办法
这个时候我们就要想一个办法，让节点之间共享数据
要在两个相互独立的节点之间传递数据，首先我们就不能让其中一个节点直接持有数据，而是应该把数据存储在一个任何节点都能够访问的地方
这样节点就可以去找到想要的数据进行读取或修改。这样一种存储共享数据的地方我们称之为Blackboard（黑板）

Blackboard具体到实现上其实也很简单，只需要用一个字典来存储黑板值，为了方便查找，一个key对应一个value，key就是黑板值得名称
不过为了用一个字典存储所有类型的黑板值，我们需要对数据做一层封装。（使用ScriptableObject，或者直接使用MonoBehavior来存储）

帧同步如何解决外挂的问题？


帧同步：我们考虑的是以固定的时间间隔更新整个游戏状态，确保所有玩家在相同的时间内看到相同的画面。
状态同步：更关注在游戏状态发生变化时，将这些变化传递给其他玩家，以确保所有玩家对游戏中的关键事件有一致的看法。

帧同步： 是在固定的时间间隔内（通常以帧为单位），更新整个游戏状态。
这确保所有玩家在相同的时间内看到相同的游戏画面。不仅仅是定时，而是以固定的频率。

状态同步： 是在游戏状态发生变化时，将这些变化传递给其他玩家。这可以包括玩家的操作、移动、战斗等。
状态同步确保所有玩家对游戏中的关键事件有一致的看法，而不仅仅是根据玩家的操作。

简而言之，帧同步是定期更新整个游戏状态，而状态同步是在关键事件发生时更新。


如何对lua进行调试？如何分析lua的性能？profiler的工作原理是什么?
使用os.clock()： Lua中的os.clock()函数可以用于简单的性能计时。在关键代码段的开始和结束位置分别调用os.clock()，然后计算差值，即可得到代码段的执行时间。

lua
Copy code
local startTime = os.clock()
-- 执行一些代码
local endTime = os.clock()
local elapsedTime = endTime - startTime
print("Elapsed Time: " .. elapsedTime)

客户端的协议加密解密的做法是什么？
资源包加密/解密：定义了一个字节数组（加密因子），然后对每一个ab包的字节流数据进行一个异或的操作。

客户端的网络是怎么实现的？

tcp的粘包问题该怎么解决？
(要先理解什么是粘包)
TCP粘包问题是在网络通信中常见的一种问题
它指的是发送方在发送数据时，TCP会将多个小的数据包粘合在一起，接收方在接收时无法正确区分这些数据包
1消息长度固定： 在通信协议中，可以规定每个消息的长度是固定的。发送方在发送消息前，先发送消息的长度，接收方首先读取消息长度，然后再读取对应长度的数据。
这样可以确保接收方能够正确解析每个消息。这种方法简单直接，但对于变长消息不太适用。
2特殊字符分隔： 在消息之间添加特殊字符作为分隔符，接收方根据分隔符来切分消息。这种方法适用于文本协议，但对于二进制协议可能不太方便。
3使用消息头： 在消息中添加头部信息，头部包含消息的长度等信息。接收方首先读取头部信息，然后再根据头部信息读取实际的数据。这种方法灵活性较高，适用于不同长度消息的场景。
4采用分隔符或固定长度的协议： 使用现有的协议，如HTTP、WebSocket等，它们已经定义了消息的分隔符或采用了固定长度的消息格式。这样可以避免自行处理粘包问题。
5应用层协议： 在应用层设计专门的协议来处理粘包问题。例如，消息中包含消息类型、消息长度等字段，接收方根据这些信息来正确解析消息。这需要在应用层进行额外的协议设计。


做过哪些性能优化？
1:代码优化：
2:资源优化：(动画优化、纹理优化、模型优化)
3:UI优化：
4:性能监控和分析：

贴图资源优化：1、降低最大分辨率 2、纹理压缩格式 3、取消勾选Read/Write Enabled 4、禁用多余的Mip Map（有点类似LOD技术，根据渲染距离使用不同精度的图片） 5、打包图集
模型优化：（尽量避免模型留有多余的面数）1、禁用掉Reader/Write Enables:2、尽量不要勾选不需要的功能选项3、设置一些关于质量与性能的选项
动画优化：（总结两点1.删除不需要的序列帧 2.降低帧信息的精度）
（1）.降低帧信息的精度 
unityEditor存储的动画文件是text文件,所以缩短浮点数精度，会导致文件表面上有所减少，裁剪动画文件的精度，会让动画的点变的更加稀疏（会将一些曲线上相近的数值，变为一致），Dense Curve是减少了，Constant Curve是增多了，总的内存是减小了。
（2）. 去除没有变化的帧动画
去除没有变化的Position，Rotation序列帧，只留头尾两帧。
（3）. 去除冗余Scale曲线数据
fbx中很少用到Scale曲线做动画，所以在跟美术的小伙伴确定之后，这部分是可以去除的。PS（如果有需要的话可以在用到Scale变化的骨骼节点加上关键字区分）

Unity中的Mesh压缩：
即Player Setting中的：Vertex Compression   Optimize Mesh Data
以及Model importer中的：Mesh Compression 
Vertex Compression的实现是将顶点channel的数据格式format设置为16bit，因此可以节约运行时的内存使用（float->half)
Optimize Mesh Data则主要用来剔除不需要的channel，即剔除额外的数据。与压缩无关
Mesh Compression是使用压缩算法，将mesh数据进行压缩，结果是会减少占用硬盘的空间，但是在runtime的时候会被解压为原始精度的数据。

和Runtime时内存关系较大的是Vertex Compression的实现
是否可以进行Vertex Compression，则和模型的导入设置以及是否可以进行dynamic batching（在build 阶段，主要判断mesh的顶点数是否符合条件）有关。
简单可以归纳为以下几点：
1. 是否适合进行dynamic batching
2. 在Model Importer中是否开启了Read/Write Enabled
3. 在Model Importer中是否开启了Mesh Compression（是的，很吃惊是吧）

Mesh Compression（网格压缩）:
目的是减小模型在硬盘上的存储空间，以减小应用的包体大小。

Vertex Compression（顶点压缩）:
目的是在运行时减小模型在内存中的占用，提高运行时性能。

Optimize Mesh Data（优化网格数据）:
包括一系列优化步骤，旨在在运行时减小内存占用。

开启动态合批时，对一些小模型（vertex count<300）Vertex Compression是无效的

总结（开启读写会使内存翻倍。
为了优化Mesh的内存开销，不要开启Mesh Compression，以避免Vertex Compression的失效）

